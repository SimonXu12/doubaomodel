<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>AR 3D模型交互</title>
  <!-- 引入外部资源 -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ar.js@3.3.0/aframe/build/aframe-min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.19.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose@0.1.0/dist/handpose.min.js"></script>
  
  <!-- Tailwind 配置 -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#4F46E5',
            secondary: '#10B981',
            dark: '#1E293B',
            light: '#F8FAFC'
          },
          fontFamily: {
            inter: ['Inter', 'sans-serif'],
          },
        },
      }
    }
  </script>
  
  <style type="text/tailwindcss">
    @layer utilities {
      .content-auto {
        content-visibility: auto;
      }
      .backdrop-blur-xl {
        backdrop-filter: blur(24px);
      }
      .btn-hover {
        @apply transition-all duration-300 hover:scale-110 hover:shadow-lg active:scale-95;
      }
      .control-btn {
        @apply w-12 h-12 rounded-full bg-white/80 backdrop-blur-lg flex items-center justify-center shadow-md btn-hover;
      }
    }
  </style>
  
  <style>
    /* 基础样式 */
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: 'Inter', sans-serif;
      touch-action: manipulation;
    }
    
    /* AR场景容器 */
    #ar-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
      display: none; /* 初始隐藏，获取权限后显示 */
    }
    
    /* 控制栏样式 */
    .controls {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      display: flex;
      gap: 1.5rem;
      padding: 0.5rem;
      border-radius: 1rem;
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(12px);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      display: none; /* 初始隐藏 */
    }
    
    /* 顶部信息栏 */
    .info-bar {
      position: fixed;
      top: 1rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      padding: 0.75rem 1.5rem;
      border-radius: 9999px;
      background: rgba(30, 41, 59, 0.8);
      backdrop-filter: blur(12px);
      color: white;
      font-size: 0.875rem;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      display: none; /* 初始隐藏 */
    }
    
    /* 加载指示器 */
    .loader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 100;
      background: rgba(30, 41, 59, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      transition: opacity 0.5s ease;
    }
    
    .spinner {
      width: 4rem;
      height: 4rem;
      border: 4px solid rgba(255, 255, 255, 0.2);
      border-top: 4px solid #4F46E5;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 1rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* 隐藏AR.js默认控件 */
    a-scene canvas {
      display: block;
    }
    
    /* 手势操作提示 */
    .gesture-hint {
      position: fixed;
      top: 5rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      padding: 0.5rem 1rem;
      border-radius: 9999px;
      background: rgba(255, 255, 255, 0.7);
      backdrop-filter: blur(8px);
      color: #1E293B;
      font-size: 0.75rem;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      display: none; /* 初始隐藏 */
    }
    
    /* 手掌检测提示 */
    .hand-detected {
      position: fixed;
      top: 2rem;
      right: 2rem;
      z-index: 10;
      padding: 0.5rem 1rem;
      border-radius: 9999px;
      background: rgba(16, 185, 129, 0.8);
      backdrop-filter: blur(8px);
      color: white;
      font-size: 0.75rem;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      display: none;
    }
    
    /* 权限请求按钮 */
    .permission-btn {
      background: #4F46E5;
      color: white;
      border: none;
      padding: 1rem 2rem;
      border-radius: 9999px;
      font-size: 1rem;
      font-weight: 600;
      margin-top: 2rem;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(79, 70, 229, 0.4);
      transition: all 0.3s ease;
    }
    
    .permission-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(79, 70, 229, 0.5);
    }
  </style>
</head>
<body class="bg-dark font-inter">
  <!-- 加载指示器 -->
  <div class="loader" id="loader">
    <div class="spinner"></div>
    <p class="text-lg">正在初始化AR体验...</p>
    <p class="text-sm text-gray-300 mt-2">需要相机权限才能继续</p>
    <!-- 显式权限请求按钮 -->
    <button class="permission-btn" id="request-permission">授予相机权限</button>
  </div>
  
  <!-- AR场景容器 -->
  <div id="ar-container">
    <a-scene
      vr-mode-ui="enabled: false"
      arjs="trackingMethod: best; sourceType: webcam; detectionMode: mono_and_matrix; matrixCodeType: 3x3; sourceWidth: 1280; sourceHeight: 720;"
      renderer="antialias: true; precision: medium;"
      id="ar-scene"
    >
      <!-- 相机 -->
      <a-entity camera look-controls touch-action="none"></a-entity>
      
      <!-- 3D模型 - 初始隐藏，检测到平面后显示 -->
      <a-entity
        id="model"
        visible="false"
        scale="0.5 0.5 0.5"
        position="0 0 -1"
      ></a-entity>
    </a-scene>
  </div>
  
  <!-- 信息提示 -->
  <div class="info-bar" id="info-bar">
    <i class="fa fa-info-circle mr-2"></i>
    <span>移动相机寻找平面，点击放置模型</span>
  </div>
  
  <!-- 手势操作提示 -->
  <div class="gesture-hint" id="gesture-hint">
    <i class="fa fa-hand-paper-o mr-1"></i>
    <span>双指缩放/移动 | 手掌检测中</span>
  </div>
  
  <!-- 手掌检测提示 -->
  <div class="hand-detected" id="hand-detected">
    <i class="fa fa-hand-peace-o mr-1"></i>
    <span>已检测到手掌，模型跟随中</span>
  </div>
  
  <!-- 控制栏 -->
  <div class="controls" id="controls">
    <button class="control-btn" id="switch-camera" title="切换摄像头">
      <i class="fa fa-exchange text-dark text-lg"></i>
    </button>
    <button class="control-btn" id="reset-model" title="重置模型位置">
      <i class="fa fa-refresh text-dark text-lg"></i>
    </button>
    <button class="control-btn" id="toggle-hand-tracking" title="开启/关闭手掌追踪">
      <i class="fa fa-hand-paper-o text-dark text-lg"></i>
    </button>
  </div>

  <script>
    // 全局变量
    let scene, camera, model, handModel;
    let isHandTrackingActive = true;
    let isModelPlaced = false;
    let isRearCamera = true;
    let initialScale = 0.5;
    let handPosition = null;
    let lastHandDetectedTime = 0;
    let isFollowingHand = false;
    let videoStream = null; // 存储视频流引用
    
    // DOM元素
    const loader = document.getElementById('loader');
    const infoBar = document.getElementById('info-bar');
    const gestureHint = document.getElementById('gesture-hint');
    const handDetectedIndicator = document.getElementById('hand-detected');
    const switchCameraBtn = document.getElementById('switch-camera');
    const resetModelBtn = document.getElementById('reset-model');
    const toggleHandTrackingBtn = document.getElementById('toggle-hand-tracking');
    const requestPermissionBtn = document.getElementById('request-permission');
    const arContainer = document.getElementById('ar-container');
    const controls = document.getElementById('controls');
    
    // 初始化应用
    async function initApp() {
      try {
        // 先检查是否已有相机权限
        const hasPermission = await checkCameraPermission();
        if (hasPermission) {
          // 已有权限，直接初始化
          requestPermissionBtn.style.display = 'none';
          await startAR体验();
        } else {
          // 显示权限请求按钮
          requestPermissionBtn.style.display = 'block';
        }
      } catch (error) {
        console.error('初始化失败:', error);
        showError('初始化失败，请刷新页面重试');
      }
    }
    
    // 检查相机权限
    async function checkCameraPermission() {
      try {
        // 检查浏览器是否支持媒体设备API
        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
          return false;
        }
        
        // 枚举设备，检查是否已有相机权限
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        
        // 如果有视频设备且标签不为空，说明已有权限
        return videoDevices.length > 0 && videoDevices.some(device => device.label);
      } catch (error) {
        console.error('检查相机权限失败:', error);
        return false;
      }
    }
    
    // 显式请求相机权限
    async function requestCameraPermission() {
      try {
        loader.querySelector('p').textContent = '正在请求相机权限...';
        requestPermissionBtn.disabled = true;
        requestPermissionBtn.textContent = '请求中...';
        
        // 请求相机权限（使用后置摄像头）
        const constraints = {
          video: {
            facingMode: isRearCamera ? 'environment' : 'user',
            width: { ideal: 1280 },
            height: { ideal: 720 }
          },
          audio: false
        };
        
        // 获取视频流
        videoStream = await navigator.mediaDevices.getUserMedia(constraints);
        
        // 权限获取成功，开始AR体验
        await startAR体验();
        
      } catch (error) {
        console.error('获取相机权限失败:', error);
        
        if (error.name === 'NotAllowedError') {
          showError('相机权限被拒绝，请在浏览器设置中启用权限');
        } else if (error.name === 'NotFoundError') {
          showError('未找到摄像头设备');
        } else {
          showError('获取相机权限失败: ' + error.message);
        }
        
        requestPermissionBtn.disabled = false;
        requestPermissionBtn.textContent = '重新请求权限';
      }
    }
    
    // 开始AR体验
    async function startAR体验() {
      try {
        loader.querySelector('p').textContent = '正在初始化AR场景...';
        
        // 初始化AR场景
        await initARScene();
        
        // 加载3D模型
        await load3DModel();
        
        // 初始化手掌检测模型
        await initHandTracking();
        
        // 设置事件监听
        setupEventListeners();
        
        // 隐藏加载指示器，显示AR场景
        setTimeout(() => {
          loader.style.opacity = 0;
          setTimeout(() => {
            loader.style.display = 'none';
            arContainer.style.display = 'block';
            infoBar.style.display = 'flex';
            gestureHint.style.display = 'flex';
            controls.style.display = 'flex';
          }, 500);
        }, 1000);
        
      } catch (error) {
        console.error('AR体验启动失败:', error);
        showError('AR体验启动失败，请重试');
        throw error;
      }
    }
    
    // 初始化AR场景（修复版）
    function initARScene() {
      return new Promise((resolve, reject) => {
        scene = document.querySelector('a-scene');
        
        // 监听AR.js加载事件
        scene.addEventListener('loaded', () => {
          console.log('AR场景加载完成');
          camera = scene.querySelector('a-camera');
          
          // 确保AR.js正确使用视频流
          setTimeout(() => {
            const video = document.querySelector('video');
            if (video && videoStream) {
              // 将获取的视频流分配给AR.js的视频元素
              video.srcObject = videoStream;
              video.play().catch(err => console.warn('视频播放警告:', err));
            }
            resolve();
          }, 500);
        });
        
        // 监听AR.js错误事件
        scene.addEventListener('error', (err) => {
          console.error('AR场景错误:', err);
          reject(err);
        });
        
        // 设置超时处理
        setTimeout(() => {
          if (!camera) {
            reject(new Error('AR场景初始化超时'));
          }
        }, 10000);
      });
    }
    
    // 加载3D模型
    function load3DModel() {
      return new Promise((resolve, reject) => {
        const modelEntity = document.getElementById('model');
        const gltfLoader = new THREE.GLTFLoader();
        
        // 加载示例模型（使用更可靠的CDN链接）
        gltfLoader.load(
          'https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Models/2.0/Duck/glTF/Duck.gltf',
          (gltf) => {
            // 将Three.js模型转换为A-Frame实体
            const modelObject = new THREE.Group();
            modelObject.add(gltf.scene);
            
            // 调整模型大小和位置
            modelObject.scale.set(initialScale, initialScale, initialScale);
            modelObject.position.set(0, 0, -1);
            
            // 添加到A-Frame实体
            modelEntity.setObject3D('mesh', modelObject);
            model = modelEntity;
            
            console.log('3D模型加载完成');
            resolve();
          },
          (xhr) => {
            console.log(`模型加载中: ${(xhr.loaded / xhr.total * 100).toFixed(0)}%`);
          },
          (error) => {
            console.error('模型加载失败:', error);
            reject(error);
          }
        );
      });
    }
    
    // 初始化手掌检测
    async function initHandTracking() {
      try {
        // 加载handpose模型
        handModel = await handpose.load();
        console.log('手掌检测模型加载完成');
        
        // 开始手掌检测
        startHandDetection();
      } catch (error) {
        console.error('手掌检测初始化失败:', error);
        isHandTrackingActive = false;
        toggleHandTrackingBtn.querySelector('i').classList.add('text-gray-400');
        gestureHint.innerHTML = `<i class="fa fa-hand-paper-o mr-1"></i><span>双指缩放/移动 | 手掌追踪不可用</span>`;
      }
    }
    
    // 开始手掌检测
    async function startHandDetection() {
      if (!isHandTrackingActive || !handModel) return;
      
      try {
        // 获取视频流（优先使用已有的流）
        let video = document.querySelector('video');
        
        // 如果没有视频元素或视频流，尝试获取
        if (!video || !video.srcObject) {
          if (videoStream) {
            video.srcObject = videoStream;
            await video.play();
          } else {
            setTimeout(startHandDetection, 100);
            return;
          }
        }
        
        // 确保视频已加载
        if (video.readyState < 2) {
          setTimeout(startHandDetection, 100);
          return;
        }
        
        // 检测手掌
        const predictions = await handModel.estimateHands(video);
        
        if (predictions.length > 0) {
          // 获取手掌中心位置（使用手腕和中指根部的中点）
          const hand = predictions[0];
          const wrist = hand.landmarks[0];
          const middleFingerBase = hand.landmarks[9];
          
          // 计算手掌中心
          const handX = (wrist[0] + middleFingerBase[0]) / 2;
          const handY = (wrist[1] + middleFingerBase[1]) / 2;
          
          // 转换为标准化坐标
          const videoWidth = video.videoWidth || video.width;
          const videoHeight = video.videoHeight || video.height;
          
          // 转换为屏幕坐标（0-1范围）
          const normalizedX = (handX / videoWidth) * 2 - 1;
          const normalizedY = -(handY / videoHeight) * 2 + 1;
          
          // 存储手掌位置
          handPosition = { x: normalizedX, y: normalizedY };
          lastHandDetectedTime = Date.now();
          
          // 显示手掌检测提示
          handDetectedIndicator.style.display = 'block';
          
          // 如果模型未放置，自动放置模型到手掌位置
          if (!isModelPlaced) {
            placeModelOnHand();
          } else if (isFollowingHand) {
            // 模型跟随手掌移动
            moveModelToHand();
          }
        } else {
          // 未检测到手掌
          if (Date.now() - lastHandDetectedTime > 2000) {
            handPosition = null;
            handDetectedIndicator.style.display = 'none';
            isFollowingHand = false;
          }
        }
        
        // 继续下一帧检测
        requestAnimationFrame(startHandDetection);
      } catch (error) {
        console.error('手掌检测出错:', error);
        // 不中断检测，继续尝试
        setTimeout(startHandDetection, 100);
      }
    }
    
    // 放置模型到手掌位置
    function placeModelOnHand() {
      if (!handPosition || !model || !camera) return;
      
      // 创建射线从相机到手掌位置
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2(handPosition.x, handPosition.y);
      
      raycaster.setFromCamera(mouse, camera.object3D);
      
      // 模拟平面检测（实际项目中可使用AR.js的平面检测）
      const planeZ = -1; // 固定在Z轴-1位置
      const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), planeZ);
      const intersectPoint = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, intersectPoint);
      
      // 设置模型位置
      model.setAttribute('position', {
        x: intersectPoint.x,
        y: intersectPoint.y,
        z: intersectPoint.z
      });
      
      // 显示模型
      model.setAttribute('visible', true);
      isModelPlaced = true;
      isFollowingHand = true;
      
      // 更新信息提示
      infoBar.innerHTML = `
        <i class="fa fa-check-circle text-secondary mr-2"></i>
        <span>模型已放置，双指缩放/移动，手掌可拖动</span>
      `;
    }
    
    // 移动模型到手掌位置
    function moveModelToHand() {
      if (!handPosition || !model || !camera) return;
      
      // 创建射线从相机到手掌位置
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2(handPosition.x, handPosition.y);
      
      raycaster.setFromCamera(mouse, camera.object3D);
      
      // 保持模型在固定深度
      const currentPosition = model.object3D.position;
      const targetZ = currentPosition.z;
      
      const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -targetZ);
      const intersectPoint = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, intersectPoint);
      
      // 平滑移动模型
      const lerpFactor = 0.1; // 插值因子，控制移动平滑度
      const newPosition = {
        x: THREE.MathUtils.lerp(currentPosition.x, intersectPoint.x, lerpFactor),
        y: THREE.MathUtils.lerp(currentPosition.y, intersectPoint.y, lerpFactor),
        z: targetZ
      };
      
      model.setAttribute('position', newPosition);
    }
    
    // 设置事件监听
    function setupEventListeners() {
      // 权限请求按钮点击事件
      requestPermissionBtn.addEventListener('click', requestCameraPermission);
      
      // 点击屏幕放置模型
      scene.addEventListener('click', (e) => {
        if (!isModelPlaced && e.detail.intersections.length === 0) {
          // 点击空白区域放置模型
          placeModelAtClick(e);
        }
      });
      
      // 切换摄像头
      switchCameraBtn.addEventListener('click', toggleCamera);
      
      // 重置模型位置
      resetModelBtn.addEventListener('click', resetModel);
      
      // 切换手掌追踪
      toggleHandTrackingBtn.addEventListener('click', toggleHandTracking);
      
      // 双指缩放和移动
      setupGestureControls();
      
      // 监听AR场景错误
      scene.addEventListener('arjs-video-loaded', () => {
        console.log('AR.js视频加载完成');
      });
      
      scene.addEventListener('arjs-tracking-lost', () => {
        console.log('追踪丢失');
        infoBar.innerHTML = `<i class="fa fa-exclamation-triangle mr-2"></i><span>追踪丢失，请移动相机寻找平面</span>`;
      });
      
      scene.addEventListener('arjs-tracking-found', () => {
        console.log('追踪恢复');
        if (isModelPlaced) {
          infoBar.innerHTML = `
            <i class="fa fa-check-circle text-secondary mr-2"></i>
            <span>模型已放置，双指缩放/移动${isHandTrackingActive ? '，手掌可拖动' : ''}</span>
          `;
        } else {
          infoBar.innerHTML = `<i class="fa fa-info-circle mr-2"></i><span>移动相机寻找平面，点击放置模型</span>`;
        }
      });
    }
    
    // 点击放置模型
    function placeModelAtClick(event) {
      if (!model || !camera) return;
      
      // 获取点击位置
      const touch = event.touches ? event.touches[0] : event;
      const x = (touch.clientX / window.innerWidth) * 2 - 1;
      const y = -(touch.clientY / window.innerHeight) * 2 + 1;
      
      // 创建射线
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2(x, y);
      
      raycaster.setFromCamera(mouse, camera.object3D);
      
      // 模拟平面检测
      const planeZ = -1;
      const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), planeZ);
      const intersectPoint = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, intersectPoint);
      
      // 设置模型位置
      model.setAttribute('position', {
        x: intersectPoint.x,
        y: intersectPoint.y,
        z: intersectPoint.z
      });
      
      // 显示模型
      model.setAttribute('visible', true);
      isModelPlaced = true;
      
      // 更新信息提示
      infoBar.innerHTML = `
        <i class="fa fa-check-circle text-secondary mr-2"></i>
        <span>模型已放置，双指缩放/移动，手掌可拖动</span>
      `;
    }
    
    // 切换摄像头（修复版）
    async function toggleCamera() {
      isRearCamera = !isRearCamera;
      
      // 停止当前视频流
      if (videoStream) {
        videoStream.getTracks().forEach(track => track.stop());
      }
      
      try {
        // 显示加载状态
        loader.style.display = 'flex';
        loader.style.opacity = 1;
        loader.querySelector('p').textContent = `正在切换到${isRearCamera ? '后置' : '前置'}摄像头...`;
        
        // 请求新的视频流
        const constraints = {
          video: {
            facingMode: isRearCamera ? 'environment' : 'user',
            width: { ideal: 1280 },
            height: { ideal: 720 }
          },
          audio: false
        };
        
        videoStream = await navigator.mediaDevices.getUserMedia(constraints);
        
        // 更新AR.js摄像头设置
        const arjs = scene.getAttribute('arjs');
        arjs.sourceType = 'webcam';
        arjs.sourceId = isRearCamera ? '' : 'user';
        scene.setAttribute('arjs', arjs);
        
        // 重启AR场景
        scene.reset();
        
        // 更新按钮图标
        const icon = switchCameraBtn.querySelector('i');
        if (isRearCamera) {
          icon.classList.remove('fa-user');
          icon.classList.add('fa-exchange');
        } else {
          icon.classList.remove('fa-exchange');
          icon.classList.add('fa-user');
        }
        
        // 隐藏加载状态
        setTimeout(() => {
          loader.style.opacity = 0;
          setTimeout(() => {
            loader.style.display = 'none';
          }, 500);
        }, 1000);
        
        // 显示切换提示
        infoBar.innerHTML = `
          <i class="fa fa-camera mr-2"></i>
          <span>已切换到${isRearCamera ? '后置' : '前置'}摄像头</span>
        `;
        
        setTimeout(() => {
          if (isModelPlaced) {
            infoBar.innerHTML = `
              <i class="fa fa-check-circle text-secondary mr-2"></i>
              <span>模型已放置，双指缩放/移动${isHandTrackingActive ? '，手掌可拖动' : ''}</span>
            `;
          }
        }, 2000);
        
      } catch (error) {
        console.error('切换摄像头失败:', error);
        isRearCamera = !isRearCamera; // 恢复原状态
        showError(`切换摄像头失败: ${error.message}`);
        
        // 隐藏加载状态
        loader.style.opacity = 0;
        setTimeout(() => {
          loader.style.display = 'none';
        }, 500);
      }
    }
    
    // 重置模型位置
    function resetModel() {
      if (!model) return;
      
      // 重置模型位置和缩放
      model.setAttribute('position', '0 0 -1');
      model.setAttribute('scale', `${initialScale} ${initialScale} ${initialScale}`);
      model.setAttribute('rotation', '0 0 0');
      
      // 更新信息提示
      infoBar.innerHTML = `
        <i class="fa fa-refresh mr-2"></i>
        <span>模型已重置，可重新放置</span>
      `;
      
      setTimeout(() => {
        if (isModelPlaced) {
          infoBar.innerHTML = `
            <i class="fa fa-check-circle text-secondary mr-2"></i>
            <span>模型已放置，双指缩放/移动${isHandTrackingActive ? '，手掌可拖动' : ''}</span>
          `;
        }
      }, 2000);
    }
    
    // 切换手掌追踪
    function toggleHandTracking() {
      isHandTrackingActive = !isHandTrackingActive;
      
      const icon = toggleHandTrackingBtn.querySelector('i');
      if (isHandTrackingActive) {
        icon.classList.remove('text-gray-400');
        icon.classList.add('text-dark');
        infoBar.innerHTML = `
          <i class="fa fa-hand-paper-o mr-2"></i>
          <span>手掌追踪已开启，将模型放在手掌上</span>
        `;
        // 重启手掌检测
        startHandDetection();
        gestureHint.innerHTML = `<i class="fa fa-hand-paper-o mr-1"></i><span>双指缩放/移动 | 手掌检测中</span>`;
      } else {
        icon.classList.remove('text-dark');
        icon.classList.add('text-gray-400');
        handDetectedIndicator.style.display = 'none';
        infoBar.innerHTML = `
          <i class="fa fa-hand-paper-o mr-2"></i>
          <span>手掌追踪已关闭，双指操作模型</span>
        `;
        gestureHint.innerHTML = `<i class="fa fa-hand-paper-o mr-1"></i><span>双指缩放/移动 | 手掌追踪已关闭</span>`;
      }
      
      setTimeout(() => {
        if (isModelPlaced) {
          infoBar.innerHTML = `
            <i class="fa fa-check-circle text-secondary mr-2"></i>
            <span>模型已放置，双指缩放/移动${isHandTrackingActive ? '，手掌可拖动' : ''}</span>
          `;
        }
      }, 2000);
    }
    
    // 设置手势控制（双指缩放、移动）
    function setupGestureControls() {
      let isDragging = false;
      let initialTouchDistance = 0;
      let initialScale = 0.5;
      let initialPosition = { x: 0, y: 0 };
      let initialTouchPositions = [];
      
      // 触摸开始
      document.addEventListener('touchstart', (e) => {
        if (!isModelPlaced || !model) return;
        
        const touches = e.touches;
        
        // 单指拖动
        if (touches.length === 1) {
          isDragging = true;
          const touch = touches[0];
          initialTouchPositions = [{ x: touch.clientX, y: touch.clientY }];
          const currentPos = model.getAttribute('position');
          initialPosition = { x: currentPos.x, y: currentPos.y };
        }
        
        // 双指缩放
        else if (touches.length === 2) {
          isDragging = false;
          const touch1 = touches[0];
          const touch2 = touches[1];
          
          // 计算初始距离
          const dx = touch1.clientX - touch2.clientX;
          const dy = touch1.clientY - touch2.clientY;
          initialTouchDistance = Math.sqrt(dx * dx + dy * dy);
          
          // 记录初始缩放
          const currentScale = model.getAttribute('scale');
          initialScale = currentScale.x;
          
          // 记录初始位置（用于双指移动）
          initialTouchPositions = [
            { x: touch1.clientX, y: touch1.clientY },
            { x: touch2.clientX, y: touch2.clientY }
          ];
          const currentPos = model.getAttribute('position');
          initialPosition = { x: currentPos.x, y: currentPos.y };
        }
        
        // 暂停手掌跟随
        isFollowingHand = false;
      });
      
      // 触摸移动
      document.addEventListener('touchmove', (e) => {
        if (!isModelPlaced || !model) return;
        
        const touches = e.touches;
        
        // 单指拖动
        if (touches.length === 1 && isDragging) {
          const touch = touches[0];
          const deltaX = (touch.clientX - initialTouchPositions[0].x) / window.innerWidth * 2;
          const deltaY = -(touch.clientY - initialTouchPositions[0].y) / window.innerHeight * 2;
          
          // 计算新位置（根据相机距离调整移动速度）
          const currentPos = model.getAttribute('position');
          const distanceFactor = Math.abs(currentPos.z) * 0.5;
          
          model.setAttribute('position', {
            x: initialPosition.x + deltaX * distanceFactor,
            y: initialPosition.y + deltaY * distanceFactor,
            z: currentPos.z
          });
        }
        
        // 双指缩放和移动
        else if (touches.length === 2) {
          const touch1 = touches[0];
          const touch2 = touches[1];
          
          // 计算当前距离
          const dx = touch1.clientX - touch2.clientX;
          const dy = touch1.clientY - touch2.clientY;
          const currentTouchDistance = Math.sqrt(dx * dx + dy * dy);
          
          // 计算缩放比例
          const scaleRatio = currentTouchDistance / initialTouchDistance;
          let newScale = initialScale * scaleRatio;
          
          // 限制缩放范围
          newScale = Math.max(0.1, Math.min(newScale, 2.0));
          
          // 设置新缩放
          model.setAttribute('scale', `${newScale} ${newScale} ${newScale}`);
          
          // 双指移动（中心点移动）
          const initialCenterX = (initialTouchPositions[0].x + initialTouchPositions[1].x) / 2;
          const initialCenterY = (initialTouchPositions[0].y + initialTouchPositions[1].y) / 2;
          const currentCenterX = (touch1.clientX + touch2.clientX) / 2;
          const currentCenterY = (touch1.clientY + touch2.clientY) / 2;
          
          const deltaX = (currentCenterX - initialCenterX) / window.innerWidth * 2;
          const deltaY = -(currentCenterY - initialCenterY) / window.innerHeight * 2;
          
          // 计算新位置
          const currentPos = model.getAttribute('position');
          const distanceFactor = Math.abs(currentPos.z) * 0.5;
          
          model.setAttribute('position', {
            x: initialPosition.x + deltaX * distanceFactor,
            y: initialPosition.y + deltaY * distanceFactor,
            z: currentPos.z
          });
        }
      });
      
      // 触摸结束
      document.addEventListener('touchend', () => {
        isDragging = false;
        
        // 恢复手掌跟随（如果手掌仍被检测到）
        if (isHandTrackingActive && handPosition) {
          setTimeout(() => {
            isFollowingHand = true;
          }, 500);
        }
      });
    }
    
    // 显示错误信息
    function showError(message) {
      loader.innerHTML = `
        <div class="text-red-400 mb-2"><i class="fa fa-exclamation-circle text-2xl"></i></div>
        <p class="text-lg">${message}</p>
        <button class="permission-btn mt-4" onclick="window.location.reload()">刷新页面</button>
      `;
      loader.style.opacity = 1;
      loader.style.display = 'flex';
    }
    
    // 页面加载完成后初始化
    window.addEventListener('load', initApp);
    
    // 监听页面隐藏/显示，处理视频流
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && videoStream) {
        // 页面隐藏时暂停视频流
        videoStream.getTracks().forEach(track => track.enabled = false);
      } else if (videoStream) {
        // 页面显示时恢复视频流
        videoStream.getTracks().forEach(track => track.enabled = true);
      }
    });
  </script>
</body>
</html>
