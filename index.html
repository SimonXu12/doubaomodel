<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>AR 3D模型交互</title>
  <!-- 引入外部资源 -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ar.js@3.3.0/aframe/build/aframe-min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.19.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose@0.1.0/dist/handpose.min.js"></script>
  
  <!-- Tailwind 配置 -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#4F46E5',
            secondary: '#10B981',
            dark: '#1E293B',
            light: '#F8FAFC'
          },
          fontFamily: {
            inter: ['Inter', 'sans-serif'],
          },
        },
      }
    }
  </script>
  
  <style type="text/tailwindcss">
    @layer utilities {
      .content-auto {
        content-visibility: auto;
      }
      .backdrop-blur-xl {
        backdrop-filter: blur(24px);
      }
      .btn-hover {
        @apply transition-all duration-300 hover:scale-110 hover:shadow-lg active:scale-95;
      }
      .control-btn {
        @apply w-12 h-12 rounded-full bg-white/80 backdrop-blur-lg flex items-center justify-center shadow-md btn-hover;
      }
    }
  </style>
  
  <style>
    /* 基础样式 */
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: 'Inter', sans-serif;
      touch-action: manipulation;
    }
    
    /* AR场景容器 */
    #ar-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
    }
    
    /* 控制栏样式 */
    .controls {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      display: flex;
      gap: 1.5rem;
      padding: 0.5rem;
      border-radius: 1rem;
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(12px);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }
    
    /* 顶部信息栏 */
    .info-bar {
      position: fixed;
      top: 1rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      padding: 0.75rem 1.5rem;
      border-radius: 9999px;
      background: rgba(30, 41, 59, 0.8);
      backdrop-filter: blur(12px);
      color: white;
      font-size: 0.875rem;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }
    
    /* 加载指示器 */
    .loader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 100;
      background: rgba(30, 41, 59, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      transition: opacity 0.5s ease;
    }
    
    .spinner {
      width: 4rem;
      height: 4rem;
      border: 4px solid rgba(255, 255, 255, 0.2);
      border-top: 4px solid #4F46E5;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 1rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* 隐藏AR.js默认控件 */
    a-scene canvas {
      display: block;
    }
    
    /* 手势操作提示 */
    .gesture-hint {
      position: fixed;
      top: 5rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      padding: 0.5rem 1rem;
      border-radius: 9999px;
      background: rgba(255, 255, 255, 0.7);
      backdrop-filter: blur(8px);
      color: #1E293B;
      font-size: 0.75rem;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    
    /* 手掌检测提示 */
    .hand-detected {
      position: fixed;
      top: 2rem;
      right: 2rem;
      z-index: 10;
      padding: 0.5rem 1rem;
      border-radius: 9999px;
      background: rgba(16, 185, 129, 0.8);
      backdrop-filter: blur(8px);
      color: white;
      font-size: 0.75rem;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      display: none;
    }
  </style>
</head>
<body class="bg-dark font-inter">
  <!-- 加载指示器 -->
  <div class="loader" id="loader">
    <div class="spinner"></div>
    <p class="text-lg">正在初始化AR体验...</p>
    <p class="text-sm text-gray-300 mt-2">请授予相机权限以继续</p>
  </div>
  
  <!-- AR场景容器 -->
  <div id="ar-container">
    <a-scene
      vr-mode-ui="enabled: false"
      arjs="trackingMethod: best; sourceType: webcam; detectionMode: mono_and_matrix; matrixCodeType: 3x3;"
      renderer="antialias: true; precision: medium;"
      id="ar-scene"
    >
      <!-- 相机 -->
      <a-entity camera look-controls touch-action="none"></a-entity>
      
      <!-- 3D模型 - 初始隐藏，检测到平面后显示 -->
      <a-entity
        id="model"
        visible="false"
        scale="0.5 0.5 0.5"
        position="0 0 -1"
      ></a-entity>
    </a-scene>
  </div>
  
  <!-- 信息提示 -->
  <div class="info-bar" id="info-bar">
    <i class="fa fa-info-circle mr-2"></i>
    <span>移动相机寻找平面，点击放置模型</span>
  </div>
  
  <!-- 手势操作提示 -->
  <div class="gesture-hint">
    <i class="fa fa-hand-paper-o mr-1"></i>
    <span>双指缩放/移动 | 手掌检测中</span>
  </div>
  
  <!-- 手掌检测提示 -->
  <div class="hand-detected" id="hand-detected">
    <i class="fa fa-hand-peace-o mr-1"></i>
    <span>已检测到手掌，模型跟随中</span>
  </div>
  
  <!-- 控制栏 -->
  <div class="controls">
    <button class="control-btn" id="switch-camera" title="切换摄像头">
      <i class="fa fa-exchange text-dark text-lg"></i>
    </button>
    <button class="control-btn" id="reset-model" title="重置模型位置">
      <i class="fa fa-refresh text-dark text-lg"></i>
    </button>
    <button class="control-btn" id="toggle-hand-tracking" title="开启/关闭手掌追踪">
      <i class="fa fa-hand-paper-o text-dark text-lg"></i>
    </button>
  </div>

  <script>
    // 全局变量
    let scene, camera, model, handModel;
    let isHandTrackingActive = true;
    let isModelPlaced = false;
    let isRearCamera = true;
    let initialScale = 0.5;
    let handPosition = null;
    let lastHandDetectedTime = 0;
    let isFollowingHand = false;
    
    // DOM元素
    const loader = document.getElementById('loader');
    const infoBar = document.getElementById('info-bar');
    const handDetectedIndicator = document.getElementById('hand-detected');
    const switchCameraBtn = document.getElementById('switch-camera');
    const resetModelBtn = document.getElementById('reset-model');
    const toggleHandTrackingBtn = document.getElementById('toggle-hand-tracking');
    
    // 初始化应用
    async function initApp() {
      try {
        // 等待AR场景加载完成
        await initARScene();
        
        // 加载3D模型
        await load3DModel();
        
        // 初始化手掌检测模型
        await initHandTracking();
        
        // 设置事件监听
        setupEventListeners();
        
        // 隐藏加载指示器
        setTimeout(() => {
          loader.style.opacity = 0;
          setTimeout(() => {
            loader.style.display = 'none';
          }, 500);
        }, 1000);
      } catch (error) {
        console.error('初始化失败:', error);
        loader.innerHTML = `
          <div class="text-red-400 mb-2"><i class="fa fa-exclamation-circle text-2xl"></i></div>
          <p class="text-lg">初始化失败</p>
          <p class="text-sm text-gray-300 mt-2">请检查相机权限或刷新页面重试</p>
        `;
      }
    }
    
    // 初始化AR场景
    function initARScene() {
      return new Promise((resolve) => {
        scene = document.querySelector('a-scene');
        
        // 等待场景加载完成
        scene.addEventListener('loaded', () => {
          console.log('AR场景加载完成');
          camera = scene.querySelector('a-camera');
          resolve();
        });
      });
    }
    
    // 加载3D模型
    function load3DModel() {
      return new Promise((resolve, reject) => {
        const modelEntity = document.getElementById('model');
        const gltfLoader = new THREE.GLTFLoader();
        
        // 加载示例模型（可替换为自定义模型）
        gltfLoader.load(
          'https://cdn.jsdelivr.net/npm/three-gltf-sample-models@1.0.1/models/Duck/glTF/Duck.gltf',
          (gltf) => {
            // 将Three.js模型转换为A-Frame实体
            const modelObject = new THREE.Group();
            modelObject.add(gltf.scene);
            
            // 调整模型大小和位置
            modelObject.scale.set(initialScale, initialScale, initialScale);
            modelObject.position.set(0, 0, -1);
            
            // 添加到A-Frame实体
            modelEntity.setObject3D('mesh', modelObject);
            model = modelEntity;
            
            console.log('3D模型加载完成');
            resolve();
          },
          (xhr) => {
            console.log(`模型加载中: ${(xhr.loaded / xhr.total * 100).toFixed(0)}%`);
          },
          (error) => {
            console.error('模型加载失败:', error);
            reject(error);
          }
        );
      });
    }
    
    // 初始化手掌检测
    async function initHandTracking() {
      try {
        // 加载handpose模型
        handModel = await handpose.load();
        console.log('手掌检测模型加载完成');
        
        // 开始手掌检测
        startHandDetection();
      } catch (error) {
        console.error('手掌检测初始化失败:', error);
        isHandTrackingActive = false;
        toggleHandTrackingBtn.querySelector('i').classList.add('text-gray-400');
      }
    }
    
    // 开始手掌检测
    async function startHandDetection() {
      if (!isHandTrackingActive || !handModel) return;
      
      try {
        // 获取视频流（与AR.js共享）
        const video = document.querySelector('video');
        if (!video) {
          setTimeout(startHandDetection, 100);
          return;
        }
        
        // 检测手掌
        const predictions = await handModel.estimateHands(video);
        
        if (predictions.length > 0) {
          // 获取手掌中心位置（使用手腕和中指根部的中点）
          const hand = predictions[0];
          const wrist = hand.landmarks[0];
          const middleFingerBase = hand.landmarks[9];
          
          // 计算手掌中心
          const handX = (wrist[0] + middleFingerBase[0]) / 2;
          const handY = (wrist[1] + middleFingerBase[1]) / 2;
          
          // 转换为标准化坐标
          const videoWidth = video.videoWidth;
          const videoHeight = video.videoHeight;
          
          // 转换为屏幕坐标（0-1范围）
          const normalizedX = (handX / videoWidth) * 2 - 1;
          const normalizedY = -(handY / videoHeight) * 2 + 1;
          
          // 存储手掌位置
          handPosition = { x: normalizedX, y: normalizedY };
          lastHandDetectedTime = Date.now();
          
          // 显示手掌检测提示
          handDetectedIndicator.style.display = 'block';
          
          // 如果模型未放置，自动放置模型到手掌位置
          if (!isModelPlaced) {
            placeModelOnHand();
          } else if (isFollowingHand) {
            // 模型跟随手掌移动
            moveModelToHand();
          }
        } else {
          // 未检测到手掌
          if (Date.now() - lastHandDetectedTime > 2000) {
            handPosition = null;
            handDetectedIndicator.style.display = 'none';
            isFollowingHand = false;
          }
        }
        
        // 继续下一帧检测
        requestAnimationFrame(startHandDetection);
      } catch (error) {
        console.error('手掌检测出错:', error);
        setTimeout(startHandDetection, 100);
      }
    }
    
    // 放置模型到手掌位置
    function placeModelOnHand() {
      if (!handPosition || !model || !camera) return;
      
      // 创建射线从相机到手掌位置
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2(handPosition.x, handPosition.y);
      
      raycaster.setFromCamera(mouse, camera.object3D);
      
      // 模拟平面检测（实际项目中可使用AR.js的平面检测）
      const planeZ = -1; // 固定在Z轴-1位置
      const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), planeZ);
      const intersectPoint = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, intersectPoint);
      
      // 设置模型位置
      model.setAttribute('position', {
        x: intersectPoint.x,
        y: intersectPoint.y,
        z: intersectPoint.z
      });
      
      // 显示模型
      model.setAttribute('visible', true);
      isModelPlaced = true;
      isFollowingHand = true;
      
      // 更新信息提示
      infoBar.innerHTML = `
        <i class="fa fa-check-circle text-secondary mr-2"></i>
        <span>模型已放置，双指缩放/移动，手掌可拖动</span>
      `;
    }
    
    // 移动模型到手掌位置
    function moveModelToHand() {
      if (!handPosition || !model || !camera) return;
      
      // 创建射线从相机到手掌位置
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2(handPosition.x, handPosition.y);
      
      raycaster.setFromCamera(mouse, camera.object3D);
      
      // 保持模型在固定深度
      const currentPosition = model.object3D.position;
      const targetZ = currentPosition.z;
      
      const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -targetZ);
      const intersectPoint = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, intersectPoint);
      
      // 平滑移动模型
      const lerpFactor = 0.1; // 插值因子，控制移动平滑度
      const newPosition = {
        x: THREE.MathUtils.lerp(currentPosition.x, intersectPoint.x, lerpFactor),
        y: THREE.MathUtils.lerp(currentPosition.y, intersectPoint.y, lerpFactor),
        z: targetZ
      };
      
      model.setAttribute('position', newPosition);
    }
    
    // 设置事件监听
    function setupEventListeners() {
      // 点击屏幕放置模型
      scene.addEventListener('click', (e) => {
        if (!isModelPlaced && e.detail.intersections.length === 0) {
          // 点击空白区域放置模型
          placeModelAtClick(e);
        }
      });
      
      // 切换摄像头
      switchCameraBtn.addEventListener('click', toggleCamera);
      
      // 重置模型位置
      resetModelBtn.addEventListener('click', resetModel);
      
      // 切换手掌追踪
      toggleHandTrackingBtn.addEventListener('click', toggleHandTracking);
      
      // 双指缩放和移动
      setupGestureControls();
    }
    
    // 点击放置模型
    function placeModelAtClick(event) {
      if (!model || !camera) return;
      
      // 获取点击位置
      const touch = event.touches ? event.touches[0] : event;
      const x = (touch.clientX / window.innerWidth) * 2 - 1;
      const y = -(touch.clientY / window.innerHeight) * 2 + 1;
      
      // 创建射线
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2(x, y);
      
      raycaster.setFromCamera(mouse, camera.object3D);
      
      // 模拟平面检测
      const planeZ = -1;
      const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), planeZ);
      const intersectPoint = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, intersectPoint);
      
      // 设置模型位置
      model.setAttribute('position', {
        x: intersectPoint.x,
        y: intersectPoint.y,
        z: intersectPoint.z
      });
      
      // 显示模型
      model.setAttribute('visible', true);
      isModelPlaced = true;
      
      // 更新信息提示
      infoBar.innerHTML = `
        <i class="fa fa-check-circle text-secondary mr-2"></i>
        <span>模型已放置，双指缩放/移动，手掌可拖动</span>
      `;
    }
    
    // 切换摄像头
    function toggleCamera() {
      isRearCamera = !isRearCamera;
      
      // 更新AR.js摄像头设置
      const arjs = scene.getAttribute('arjs');
      arjs.sourceType = 'webcam';
      arjs.sourceId = isRearCamera ? '' : 'user'; // user表示前置摄像头
      scene.setAttribute('arjs', arjs);
      
      // 重启AR场景
      scene.reset();
      
      // 更新按钮图标
      const icon = switchCameraBtn.querySelector('i');
      if (isRearCamera) {
        icon.classList.remove('fa-user');
        icon.classList.add('fa-exchange');
      } else {
        icon.classList.remove('fa-exchange');
        icon.classList.add('fa-user');
      }
      
      // 显示切换提示
      infoBar.innerHTML = `
        <i class="fa fa-camera mr-2"></i>
        <span>已切换到${isRearCamera ? '后置' : '前置'}摄像头</span>
      `;
      
      setTimeout(() => {
        if (isModelPlaced) {
          infoBar.innerHTML = `
            <i class="fa fa-check-circle text-secondary mr-2"></i>
            <span>模型已放置，双指缩放/移动，手掌可拖动</span>
          `;
        }
      }, 2000);
    }
    
    // 重置模型位置
    function resetModel() {
      if (!model) return;
      
      // 重置模型位置和缩放
      model.setAttribute('position', '0 0 -1');
      model.setAttribute('scale', `${initialScale} ${initialScale} ${initialScale}`);
      model.setAttribute('rotation', '0 0 0');
      
      // 更新信息提示
      infoBar.innerHTML = `
        <i class="fa fa-refresh mr-2"></i>
        <span>模型已重置，可重新放置</span>
      `;
      
      setTimeout(() => {
        if (isModelPlaced) {
          infoBar.innerHTML = `
            <i class="fa fa-check-circle text-secondary mr-2"></i>
            <span>模型已放置，双指缩放/移动，手掌可拖动</span>
          `;
        }
      }, 2000);
    }
    
    // 切换手掌追踪
    function toggleHandTracking() {
      isHandTrackingActive = !isHandTrackingActive;
      
      const icon = toggleHandTrackingBtn.querySelector('i');
      if (isHandTrackingActive) {
        icon.classList.remove('text-gray-400');
        icon.classList.add('text-dark');
        infoBar.innerHTML = `
          <i class="fa fa-hand-paper-o mr-2"></i>
          <span>手掌追踪已开启，将模型放在手掌上</span>
        `;
        // 重启手掌检测
        startHandDetection();
      } else {
        icon.classList.remove('text-dark');
        icon.classList.add('text-gray-400');
        handDetectedIndicator.style.display = 'none';
        infoBar.innerHTML = `
          <i class="fa fa-hand-paper-o mr-2"></i>
          <span>手掌追踪已关闭，双指操作模型</span>
        `;
      }
      
      setTimeout(() => {
        if (isModelPlaced) {
          infoBar.innerHTML = `
            <i class="fa fa-check-circle text-secondary mr-2"></i>
            <span>模型已放置，双指缩放/移动${isHandTrackingActive ? '，手掌可拖动' : ''}</span>
          `;
        }
      }, 2000);
    }
    
    // 设置手势控制（双指缩放、移动）
    function setupGestureControls() {
      let isDragging = false;
      let initialTouchDistance = 0;
      let initialScale = 0.5;
      let initialPosition = { x: 0, y: 0 };
      let initialTouchPositions = [];
      
      // 触摸开始
      document.addEventListener('touchstart', (e) => {
        if (!isModelPlaced || !model) return;
        
        const touches = e.touches;
        
        // 单指拖动
        if (touches.length === 1) {
          isDragging = true;
          const touch = touches[0];
          initialTouchPositions = [{ x: touch.clientX, y: touch.clientY }];
          const currentPos = model.getAttribute('position');
          initialPosition = { x: currentPos.x, y: currentPos.y };
        }
        
        // 双指缩放
        else if (touches.length === 2) {
          isDragging = false;
          const touch1 = touches[0];
          const touch2 = touches[1];
          
          // 计算初始距离
          const dx = touch1.clientX - touch2.clientX;
          const dy = touch1.clientY - touch2.clientY;
          initialTouchDistance = Math.sqrt(dx * dx + dy * dy);
          
          // 记录初始缩放
          const currentScale = model.getAttribute('scale');
          initialScale = currentScale.x;
          
          // 记录初始位置（用于双指移动）
          initialTouchPositions = [
            { x: touch1.clientX, y: touch1.clientY },
            { x: touch2.clientX, y: touch2.clientY }
          ];
          const currentPos = model.getAttribute('position');
          initialPosition = { x: currentPos.x, y: currentPos.y };
        }
        
        // 暂停手掌跟随
        isFollowingHand = false;
      });
      
      // 触摸移动
      document.addEventListener('touchmove', (e) => {
        if (!isModelPlaced || !model) return;
        
        const touches = e.touches;
        
        // 单指拖动
        if (touches.length === 1 && isDragging) {
          const touch = touches[0];
          const deltaX = (touch.clientX - initialTouchPositions[0].x) / window.innerWidth * 2;
          const deltaY = -(touch.clientY - initialTouchPositions[0].y) / window.innerHeight * 2;
          
          // 计算新位置（根据相机距离调整移动速度）
          const currentPos = model.getAttribute('position');
          const distanceFactor = Math.abs(currentPos.z) * 0.5;
          
          model.setAttribute('position', {
            x: initialPosition.x + deltaX * distanceFactor,
            y: initialPosition.y + deltaY * distanceFactor,
            z: currentPos.z
          });
        }
        
        // 双指缩放和移动
        else if (touches.length === 2) {
          const touch1 = touches[0];
          const touch2 = touches[1];
          
          // 计算当前距离
          const dx = touch1.clientX - touch2.clientX;
          const dy = touch1.clientY - touch2.clientY;
          const currentTouchDistance = Math.sqrt(dx * dx + dy * dy);
          
          // 计算缩放比例
          const scaleRatio = currentTouchDistance / initialTouchDistance;
          let newScale = initialScale * scaleRatio;
          
          // 限制缩放范围
          newScale = Math.max(0.1, Math.min(newScale, 2.0));
          
          // 设置新缩放
          model.setAttribute('scale', `${newScale} ${newScale} ${newScale}`);
          
          // 双指移动（中心点移动）
          const initialCenterX = (initialTouchPositions[0].x + initialTouchPositions[1].x) / 2;
          const initialCenterY = (initialTouchPositions[0].y + initialTouchPositions[1].y) / 2;
          const currentCenterX = (touch1.clientX + touch2.clientX) / 2;
          const currentCenterY = (touch1.clientY + touch2.clientY) / 2;
          
          const deltaX = (currentCenterX - initialCenterX) / window.innerWidth * 2;
          const deltaY = -(currentCenterY - initialCenterY) / window.innerHeight * 2;
          
          // 计算新位置
          const currentPos = model.getAttribute('position');
          const distanceFactor = Math.abs(currentPos.z) * 0.5;
          
          model.setAttribute('position', {
            x: initialPosition.x + deltaX * distanceFactor,
            y: initialPosition.y + deltaY * distanceFactor,
            z: currentPos.z
          });
        }
      });
      
      // 触摸结束
      document.addEventListener('touchend', () => {
        isDragging = false;
        
        // 恢复手掌跟随（如果手掌仍被检测到）
        if (isHandTrackingActive && handPosition) {
          setTimeout(() => {
            isFollowingHand = true;
          }, 500);
        }
      });
    }
    
    // 页面加载完成后初始化
    window.addEventListener('load', initApp);
  </script>
</body>
</html>